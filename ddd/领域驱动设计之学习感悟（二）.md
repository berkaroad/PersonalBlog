# 领域驱动设计之学习感悟（二）

这篇，主要讲解领域建模的过程，先了解以下几个建模的要素。

## 模块

对于当前限界上下文，进行二次分类的划分，是可选的。如果当前的限界上下文所涵盖的聚合根比较多，并且可以从业务语义上能清晰得进行划分，那么这个时候就需要引入模块的概念了。

具体开发语言上的实现，Java的称之为Package，C#的称之为Namespace。

## 实体（Entity）

具有唯一标识，有生命周期概念。在生命周期内，可以发生状态改变。在外部，可以通过实体标识，来获取实体本身，即唯一性标识。

自身状态的变化，通过自身提供的行为（用面向对象的概念，指方法）来改变。

注意：此实体不是指对象关系映射（ORM）中的用于关系型数据库持久化的实体。

### 唯一标识生成

- 用户提供标识：通过用户输入的信息，作为唯一标识。这种方式，如果存在改变标识的可能性，则不应该使用

- 应用程序生成唯一标识：如UUID、雪花算法、基于第三方服务的编号生成（性能相对不是太好，但对于可读性较好）

- 持久化机制生成唯一标识：如数据库的自增ID。在高并发情况下，会有性能瓶颈。而且在使用 `领域事件`时，无法在第一时间拿到唯一标识，所以这种方式一般不推荐使用。

### 标识稳定性

不应该去改变实体的唯一标识。如果存在这种情况，那么应选择其他方式作为标识，而原定义的标识，则通过唯一性约束来解决重复问题。

### 发现实体及其本质特征

举个电商库存管理的例子：

1）一个仓库，从物理划分上，有几栋楼组成，每栋楼有N个楼层，每个楼层划分了多个区域；

2）一个区域下，可以放置多个货架，每个货架可根据需要划分多个货位；

3）一个货位上可以放置1个或多个盒子，盒子是作为存放商品的容器；

4）一个仓库，为了扩容，会盖新的楼；

5）一个楼层，出于管理考虑，会调整区域的划分；

6）仓库管理员，可以按需要，将货架禁用掉，以挪作他用，或者重新调整货架的货位布局；

从以上可以分析出的实体：仓库、区域、货架；仓库具有创建楼、楼层、区域的行为；区域拥有放置货架的行为；货架可以被禁用/启用，可以重建货位布局；

## 值对象（Value Object）

`实体` 的引入，可能会带来副作用。如果实体A被实体B引用，有可能会通过实体B的修改，而导致实体A的修改，且往往这不是想要的结果，这就是副作用。这个时候就要引入 `值对象` 的概念。

相对 `实体` 而言，最大的区别是状态不可改变。判断2个值对象是否相同，是通过判断值对象内部各个属性值是否相同作为依据。

修改实体中的值对象类型的属性，只需要创建新的值对象，然后替换即可。

注意：能使用值对象，就不要使用实体。引入实体可能带来副作用之外，还增加了系统跟踪其状态的负担。

## 聚合根（Aggregate Root）

特殊的 `实体`，从业务操作角度考虑，往往是一个提供操作入口的实体。

举个例子：修改员工的教育背景信息。 操作入口是“员工信息”，通过“员工信息”修改“教育背景”。那么这个“员工信息”就是一个聚合根。

### 规则

- 一致性边界

- 设计最小边界

- 通过标识引用外部聚合根

- 边界外使用最终一致性

### 打破规则的理由

- 处于用户界面便利

- 缺乏技术

- 全局事务

- 查询性能

## 领域事件（Domain Event）

## 领域服务（Domain Service）

## 工厂（Factory）

## 仓储（Repository）

## 应用服务（Application Service）

## 实战演练
